# 통합 테스트 시나리오

이 문서는 AI 리서치 어시스턴트 애플리케이션의 통합 테스트 시나리오를 정의합니다. 통합 테스트는 여러 컴포넌트가 함께 작동하는 것을 검증하며, 실제 사용자 시나리오를 기반으로 작성되었습니다.

## 목차

1. [기본 대화 흐름 시나리오](#1-기본-대화-흐름-시나리오)
2. [상태 전환 시나리오](#2-상태-전환-시나리오)
3. [대화 저장 및 로드 시나리오](#3-대화-저장-및-로드-시나리오)
4. [대화 요약 시나리오](#4-대화-요약-시나리오)
5. [명령어 시스템 통합 시나리오](#5-명령어-시스템-통합-시나리오)
6. [에러 처리 및 재시도 시나리오](#6-에러-처리-및-재시도-시나리오)
7. [전체 워크플로우 시나리오](#7-전체-워크플로우-시나리오)

---

## 1. 기본 대화 흐름 시나리오

### 시나리오 1.1: 일반 대화 세션

**목적**: 기본적인 대화 흐름이 정상적으로 작동하는지 검증

**전제 조건**:
- `.env` 파일에 유효한 `OPENAI_API_KEY` 설정
- `ConversationManager` 초기화 성공

**테스트 단계**:

1. **프로그램 시작**
   - `python main.py` 실행
   - 환영 메시지 출력 확인
   - 명령어 안내 출력 확인

2. **일반 질문 입력**
   ```
   You: 안녕하세요!
   ```
   - **검증 사항**:
     - AI 응답이 정상적으로 출력됨
     - 상태가 `responding`으로 변경됨
     - `message_count`가 1 증가함
     - 응답 후 상태가 `idle`로 변경됨
     - `messages` 리스트에 사용자 메시지와 AI 응답이 추가됨

3. **추가 질문 입력**
   ```
   You: Python의 리스트 컴프리헨션에 대해 설명해주세요
   ```
   - **검증 사항**:
     - 이전 대화 컨텍스트가 유지됨
     - AI가 이전 대화를 참고하여 응답함
     - `message_count`가 2 증가함 (총 3개)

**예상 결과**:
- 모든 대화가 정상적으로 기록됨
- 상태 전환이 올바르게 작동함
- 메시지 카운트가 정확함

---

## 2. 상태 전환 시나리오

### 시나리오 2.1: 리서치 모드 활성화

**목적**: 리서치 키워드 감지 시 상태 전환 및 모드별 동작 검증

**테스트 단계**:

1. **리서치 키워드 입력**
   ```
   You: Python을 조사해줘
   ```
   - **검증 사항**:
     - `determine_state()`가 `"researching"` 반환
     - 상태가 `researching`으로 변경됨
     - `RESEARCH_MODE_PROMPT`가 사용자 메시지에 추가됨
     - API 호출 시 `RESEARCH_TEMPERATURE` (0.5) 사용
     - API 호출 시 `RESEARCH_MAX_TOKENS` (1500) 사용
     - 응답이 더 상세하고 구조화됨

2. **일반 질문 입력**
   ```
   You: 고마워요
   ```
   - **검증 사항**:
     - 상태가 `responding`으로 변경됨
     - `RESPONDING_MODE_PROMPT`가 사용자 메시지에 추가됨
     - API 호출 시 `DEFAULT_TEMPERATURE` (0.7) 사용
     - API 호출 시 `MAX_TOKENS` (1000) 사용

**예상 결과**:
- 상태 전환이 올바르게 작동함
- 각 모드에 맞는 프롬프트와 설정이 적용됨

### 시나리오 2.2: 다양한 리서치 키워드 감지

**목적**: 모든 리서치 키워드가 올바르게 감지되는지 검증

**테스트 케이스**:
```
- "이 주제를 분석해주세요" → researching
- "리서치를 해주세요" → researching
- "이것에 대해 알아봐줘" → researching
- "찾아봐줘" → researching
- "조사해줘" → researching
```

**검증 사항**:
- 모든 키워드가 `researching` 상태로 전환됨
- 대소문자 구분 없이 작동함

---

## 3. 대화 저장 및 로드 시나리오

### 시나리오 3.1: 대화 저장 기능

**목적**: 대화 저장 기능이 정상적으로 작동하는지 검증

**테스트 단계**:

1. **대화 진행**
   ```
   You: 안녕하세요
   AI: [응답]
   You: Python에 대해 알려주세요
   AI: [응답]
   ```

2. **저장 명령어 실행**
   ```
   You: save
   ```
   - **검증 사항**:
     - `data/` 디렉토리가 자동 생성됨 (없는 경우)
     - JSON 파일이 생성됨
     - 파일명이 `conversation_YYYYMMDD_HHMMSS.json` 형식임
     - 파일 내용에 다음 필드가 포함됨:
       - `timestamp`: 저장 시각
       - `messages`: 전체 대화 히스토리
       - `message_count`: 대화 횟수
       - `state`: 현재 상태
     - 성공 메시지 출력: `✓ 대화가 저장되었습니다: data/conversation_...`

3. **저장된 파일 확인**
   - JSON 파일이 올바른 형식인지 확인
   - 모든 메시지가 포함되어 있는지 확인
   - 한글 인코딩이 올바른지 확인 (`ensure_ascii=False`)

**예상 결과**:
- 대화가 정상적으로 저장됨
- 파일 형식이 올바름
- 한글이 깨지지 않음

### 시나리오 3.2: 대화 로드 기능

**목적**: 저장된 대화를 복원하는 기능이 정상적으로 작동하는지 검증

**테스트 단계**:

1. **대화 저장**
   - 시나리오 3.1을 통해 대화 저장

2. **새 세션 시작**
   - 프로그램 재시작 또는 `ConversationManager` 새 인스턴스 생성

3. **대화 로드**
   ```python
   manager.load_conversation("conversation_20240115_143022.json")
   ```
   - **검증 사항**:
     - `messages`가 복원됨
     - `message_count`가 복원됨
     - `state`가 복원됨 (없으면 `"idle"`로 초기화)
     - 시스템 메시지가 유지됨

4. **로드된 대화로 계속 대화**
   ```
   You: 이전에 Python에 대해 물어봤는데, 추가로 설명해줘
   ```
   - **검증 사항**:
     - 이전 대화 컨텍스트가 유지됨
     - AI가 이전 대화를 참고하여 응답함

**예상 결과**:
- 대화가 정상적으로 복원됨
- 이전 대화 컨텍스트가 유지됨

### 시나리오 3.3: 저장 실패 처리

**목적**: 저장 실패 시 에러 처리가 올바르게 작동하는지 검증

**테스트 케이스**:

1. **권한 없는 디렉토리**
   - 읽기 전용 디렉토리에 저장 시도
   - `PermissionError` 발생 확인
   - 사용자 친화적 에러 메시지 출력 확인

2. **디스크 공간 부족**
   - 디스크 공간 부족 시뮬레이션
   - `OSError` 발생 확인
   - 에러 메시지 출력 확인

3. **잘못된 파일명**
   - 잘못된 파일명으로 저장 시도
   - 적절한 에러 처리 확인

**예상 결과**:
- 모든 에러 케이스에서 적절한 예외 처리
- 프로그램이 비정상 종료하지 않음

---

## 4. 대화 요약 시나리오

### 시나리오 4.1: 대화 요약 생성

**목적**: 대화 요약 기능이 정상적으로 작동하는지 검증

**테스트 단계**:

1. **충분한 대화 진행** (최소 4개 메시지 이상)
   ```
   You: 안녕하세요
   AI: [응답]
   You: Python에 대해 알려주세요
   AI: [응답]
   You: 리스트 컴프리헨션은?
   AI: [응답]
   You: 딕셔너리 컴프리헨션도 있나요?
   AI: [응답]
   ```

2. **요약 명령어 실행**
   ```
   You: summary
   ```
   - **검증 사항**:
     - `summarize_conversation()` 메서드 호출
     - 시스템 메시지를 제외한 메시지 수 확인
     - `MIN_MESSAGES_FOR_SUMMARY` (3) 이상인지 확인
     - 임시 메시지 리스트 생성 (원본 `messages` 변경 없음)
     - API 호출 시 `SUMMARY_TEMPERATURE` (0.3) 사용
     - 요약 텍스트가 반환됨
     - 요약이 3문장으로 생성됨
     - 원본 `messages`가 변경되지 않음

3. **요약 출력 확인**
   - 구분선과 함께 요약 출력
   - 요약 내용이 의미 있게 생성됨

**예상 결과**:
- 대화가 정상적으로 요약됨
- 원본 대화가 변경되지 않음
- 요약 품질이 일관됨

### 시나리오 4.2: 요약 조건 미충족

**목적**: 대화가 충분히 길지 않을 때 요약이 건너뛰어지는지 검증

**테스트 단계**:

1. **짧은 대화 진행** (2개 메시지)
   ```
   You: 안녕하세요
   AI: [응답]
   ```

2. **요약 명령어 실행**
   ```
   You: summary
   ```
   - **검증 사항**:
     - `MIN_MESSAGES_FOR_SUMMARY` (3) 미만임
     - "대화가 충분히 길지 않습니다" 메시지 반환
     - API 호출이 발생하지 않음

**예상 결과**:
- 요약이 건너뛰어짐
- 적절한 안내 메시지 출력

### 시나리오 4.3: 요약 실패 처리

**목적**: 요약 실패 시 에러 처리가 올바르게 작동하는지 검증

**테스트 케이스**:

1. **API 오류**
   - API 호출 실패 시뮬레이션
   - `ConversationSummaryError` 발생 확인
   - 사용자 친화적 에러 메시지 출력

2. **Rate Limit 오류**
   - Rate limit 초과 시뮬레이션
   - `RateLimitError` 처리 확인

**예상 결과**:
- 모든 에러 케이스에서 적절한 예외 처리
- 프로그램이 비정상 종료하지 않음

---

## 5. 명령어 시스템 통합 시나리오

### 시나리오 5.1: 종료 명령어 (저장 포함)

**목적**: 종료 명령어와 저장 기능이 통합되어 작동하는지 검증

**테스트 단계**:

1. **대화 진행**
   ```
   You: 안녕하세요
   AI: [응답]
   You: Python에 대해 알려주세요
   AI: [응답]
   ```

2. **종료 명령어 입력**
   ```
   You: quit
   ```
   - **검증 사항**:
     - "대화를 저장하시겠습니까? (y/n): " 메시지 출력
     - 사용자 입력 대기

3. **저장 선택 (y)**
   ```
   y
   ```
   - **검증 사항**:
     - `save_conversation()` 호출
     - 대화가 저장됨
     - 성공 메시지 출력
     - 프로그램 종료
     - 종료 메시지 출력: "대화를 종료합니다. 안녕히 가세요!"
     - 총 대화 횟수 출력

4. **종료 명령어 입력 (저장하지 않기)**
   ```
   You: quit
   n
   ```
   - **검증 사항**:
     - 저장 없이 프로그램 종료
     - 종료 메시지 출력

**예상 결과**:
- 종료 명령어가 정상적으로 작동함
- 저장 옵션이 올바르게 처리됨
- 프로그램이 깔끔하게 종료됨

### 시나리오 5.2: 다양한 종료 명령어

**목적**: 모든 종료 명령어가 작동하는지 검증

**테스트 케이스**:
```
- "quit" → 종료
- "exit" → 종료
- "종료" → 종료
```

**검증 사항**:
- 모든 명령어가 동일하게 작동함
- 대소문자 구분 없이 작동함

### 시나리오 5.3: 저장 명령어

**목적**: 저장 명령어가 정상적으로 작동하는지 검증

**테스트 단계**:

1. **대화 진행**
   ```
   You: 안녕하세요
   AI: [응답]
   ```

2. **저장 명령어 입력**
   ```
   You: save
   ```
   - **검증 사항**:
     - `handle_save_command()` 호출
     - `save_conversation()` 호출
     - 대화가 저장됨
     - 성공 메시지 출력
     - 프로그램이 계속 실행됨 (종료하지 않음)

**예상 결과**:
- 저장 명령어가 정상적으로 작동함
- 프로그램이 계속 실행됨

---

## 6. 에러 처리 및 재시도 시나리오

### 시나리오 6.1: API 재시도 로직

**목적**: API 호출 실패 시 재시도 로직이 정상적으로 작동하는지 검증

**테스트 단계**:

1. **일시적 API 오류 시뮬레이션**
   - 첫 번째 호출: `APIConnectionError` 발생
   - 두 번째 호출: 성공

2. **재시도 동작 확인**
   - **검증 사항**:
     - 첫 번째 실패 후 재시도
     - 지수 백오프 적용: 2초, 4초, 8초 대기
     - 재시도 메시지 출력: "⚠ API 호출 실패. 1번째 재시도 중... (2초 대기)"
     - 두 번째 호출 성공
     - 최종 응답 반환

**예상 결과**:
- 재시도 로직이 정상적으로 작동함
- 지수 백오프가 올바르게 적용됨
- 최종적으로 성공함

### 시나리오 6.2: 최대 재시도 횟수 초과

**목적**: 최대 재시도 횟수 초과 시 에러 처리가 올바른지 검증

**테스트 단계**:

1. **연속적인 API 오류 시뮬레이션**
   - 모든 재시도 실패 (3회)

2. **에러 처리 확인**
   - **검증 사항**:
     - 3회 재시도 후 최종 실패
     - 적절한 예외 발생 (`RateLimitError`, `APIConnectionError`, `APIError`)
     - 사용자 친화적 에러 메시지 출력
     - 프로그램이 비정상 종료하지 않음
     - 로그에 상세한 에러 정보 기록

**예상 결과**:
- 최대 재시도 횟수 초과 시 적절한 에러 처리
- 프로그램이 안정적으로 유지됨

### 시나리오 6.3: API 키 오류

**목적**: API 키가 없을 때 초기화가 실패하는지 검증

**테스트 단계**:

1. **API 키 제거**
   - `.env` 파일에서 `OPENAI_API_KEY` 제거
   - 환경변수에서 제거

2. **프로그램 시작 시도**
   ```python
   python main.py
   ```
   - **검증 사항**:
     - `APIKeyNotFoundError` 발생
     - 사용자 친화적 에러 메시지 출력
     - 프로그램이 종료 코드 1로 종료됨

**예상 결과**:
- API 키 오류가 올바르게 처리됨
- 프로그램이 안전하게 종료됨

---

## 7. 전체 워크플로우 시나리오

### 시나리오 7.1: 완전한 사용자 세션

**목적**: 실제 사용자가 프로그램을 사용하는 전체 워크플로우를 검증

**테스트 단계**:

1. **프로그램 시작**
   ```
   python main.py
   ```
   - 환영 메시지 출력 확인

2. **일반 대화**
   ```
   You: 안녕하세요!
   AI: [응답]
   ```
   - 상태: `idle` → `responding` → `idle`
   - 메시지 카운트: 1

3. **리서치 요청**
   ```
   You: Python을 조사해줘
   AI: [상세한 응답]
   ```
   - 상태: `idle` → `researching` → `idle`
   - 메시지 카운트: 2
   - 리서치 모드 설정 적용 확인

4. **추가 질문**
   ```
   You: 리스트 컴프리헨션에 대해 더 자세히 알려줘
   AI: [응답]
   ```
   - 이전 대화 컨텍스트 유지 확인

5. **대화 저장**
   ```
   You: save
   ```
   - 대화 저장 확인
   - 파일 생성 확인

6. **대화 요약**
   ```
   You: summary
   ```
   - 요약 생성 확인
   - 원본 대화 유지 확인

7. **종료 (저장)**
   ```
   You: quit
   y
   ```
   - 대화 저장 확인
   - 프로그램 종료 확인
   - 종료 메시지 출력 확인

**예상 결과**:
- 모든 기능이 통합되어 정상적으로 작동함
- 전체 워크플로우가 완료됨

### 시나리오 7.2: 대화 복원 및 이어가기

**목적**: 저장된 대화를 로드하여 이어서 대화하는 워크플로우 검증

**테스트 단계**:

1. **첫 번째 세션**
   - 대화 진행 및 저장

2. **두 번째 세션 시작**
   - 프로그램 재시작

3. **대화 로드**
   ```python
   manager.load_conversation("conversation_20240115_143022.json")
   ```

4. **이전 대화 이어가기**
   ```
   You: 이전에 Python에 대해 물어봤는데, 추가로 설명해줘
   AI: [이전 대화를 참고한 응답]
   ```
   - 이전 대화 컨텍스트 유지 확인

5. **추가 대화 및 저장**
   - 대화 계속 진행
   - 저장 확인

**예상 결과**:
- 대화가 정상적으로 복원됨
- 이전 대화 컨텍스트가 유지됨
- 이어서 대화가 가능함

---

## 테스트 실행 가이드

### 통합 테스트 실행 방법

1. **수동 테스트**
   - 각 시나리오를 수동으로 실행하여 검증
   - 실제 OpenAI API를 사용 (비용 발생 가능)

2. **자동화된 통합 테스트** (향후 구현)
   - pytest를 사용한 통합 테스트 작성
   - API 호출 모킹 또는 테스트용 API 키 사용

### 테스트 환경 설정

```bash
# 1. 가상환경 활성화
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# 2. 테스트용 .env 파일 설정
echo "OPENAI_API_KEY=test_key_here" > .env.test

# 3. 테스트 실행
pytest tests/integration/ -v
```

### 검증 체크리스트

각 시나리오 실행 후 다음 사항을 확인:

- [ ] 모든 기능이 정상적으로 작동함
- [ ] 에러 처리가 올바르게 작동함
- [ ] 로그가 정상적으로 기록됨
- [ ] 사용자 인터페이스가 올바르게 표시됨
- [ ] 파일 저장/로드가 정상적으로 작동함
- [ ] 상태 전환이 올바르게 작동함
- [ ] 메시지 카운트가 정확함

---

## 결론

이 통합 테스트 시나리오는 AI 리서치 어시스턴트 애플리케이션의 모든 주요 기능을 검증합니다. 각 시나리오는 실제 사용자 시나리오를 기반으로 작성되었으며, 여러 컴포넌트가 함께 작동하는 것을 검증합니다.

**다음 단계**:
- 이 시나리오를 기반으로 자동화된 통합 테스트 코드 작성
- CI/CD 파이프라인에 통합 테스트 추가
- 테스트 커버리지 측정 및 개선
